# 枚举类型使用指南

## 概述

`UGF.GameFramework.Data` 现已支持枚举类型，允许您在 Excel 数据表中定义和使用枚举值。枚举类型提供了更好的类型安全性和代码可读性。

## 支持的枚举格式

### 1. 显式枚举格式

在 Excel 表格的类型行中使用 `enum:EnumTypeName` 格式：

```
字段名    | PlayerType     | Status
类型      | enum:PlayerType| enum:GameStatus
描述      | 玩家类型       | 游戏状态
数据      | Warrior        | Active
```

### 2. 隐式枚举格式

直接使用枚举类型名作为字段类型：

```
字段名    | PlayerType     | Status
类型      | PlayerType     | GameStatus
描述      | 玩家类型       | 游戏状态
数据      | Mage          | Inactive
```

## 枚举值的填写方式

### 1. 使用枚举名称（推荐）

```
数据行1   | Warrior        | Active
数据行2   | Mage          | Inactive
数据行3   | Archer        | Pending
```

### 2. 使用枚举数值

```
数据行1   | 0             | 1
数据行2   | 1             | 0
数据行3   | 2             | 2
```

## 代码示例

### 1. 定义枚举类型

首先在您的项目中定义枚举类型：

```csharp
// PlayerType.cs
public enum PlayerType
{
    Warrior = 0,
    Mage = 1,
    Archer = 2,
    Rogue = 3
}

// GameStatus.cs
public enum GameStatus
{
    Inactive = 0,
    Active = 1,
    Pending = 2,
    Completed = 3
}
```

### 2. Excel 表格结构

创建一个名为 `PlayerData.xlsx` 的 Excel 文件：

| 玩家ID | 玩家类型 | 状态 | 等级 |
|--------|----------|------|------|
| Id | PlayerType | GameStatus | Level |
| int | enum:PlayerType | enum:GameStatus | int |
| 玩家唯一标识 | 玩家职业类型 | 当前状态 | 玩家等级 |
| 1001 | Warrior | Active | 10 |
| 1002 | Mage | Inactive | 15 |
| 1003 | Archer | Pending | 8 |

### 3. 生成的 DataRow 类

数据表构建器将生成如下的 DataRow 类：

```csharp
// PlayerDataRow.cs
using System.IO;
using UnityGameFramework.Runtime;

public class PlayerDataRow : IDataRow
{
    private int m_Id = 0;
    
    /// <summary>
    /// 玩家唯一标识
    /// </summary>
    public int Id { get; private set; }
    
    /// <summary>
    /// 玩家职业类型
    /// </summary>
    public PlayerType PlayerType { get; private set; }
    
    /// <summary>
    /// 当前状态
    /// </summary>
    public GameStatus Status { get; private set; }
    
    /// <summary>
    /// 玩家等级
    /// </summary>
    public int Level { get; private set; }
    
    public bool ParseDataRow(string dataRowString, object userData)
    {
        // 解析逻辑...
        return true;
    }
    
    public bool ParseDataRow(byte[] dataRowBytes, int startIndex, int length, object userData)
    {
        using (MemoryStream memoryStream = new MemoryStream(dataRowBytes, startIndex, length, false))
        {
            using (BinaryReader binaryReader = new BinaryReader(memoryStream, Encoding.UTF8))
            {
                Id = binaryReader.ReadInt32();
                PlayerType = (PlayerType)binaryReader.ReadInt32();
                Status = (GameStatus)binaryReader.ReadInt32();
                Level = binaryReader.ReadInt32();
            }
        }
        
        return true;
    }
}
```

### 4. 使用生成的数据

```csharp
// 在游戏代码中使用
public class PlayerManager : MonoBehaviour
{
    private void Start()
    {
        // 获取数据表
        var dataTable = GameEntry.DataTable.GetDataTable<PlayerDataRow>();
        
        // 查询特定玩家数据
        var playerData = dataTable.GetDataRow(1001);
        if (playerData != null)
        {
            Debug.Log($"玩家类型: {playerData.PlayerType}");
            Debug.Log($"玩家状态: {playerData.Status}");
            
            // 类型安全的枚举比较
            if (playerData.PlayerType == PlayerType.Warrior)
            {
                Debug.Log("这是一个战士!");
            }
            
            if (playerData.Status == GameStatus.Active)
            {
                Debug.Log("玩家处于活跃状态");
            }
        }
    }
}
```

## 注意事项

### 1. 枚举类型定义

- 确保枚举类型在代码中已正确定义
- 枚举值建议从 0 开始递增
- 枚举类型名称要与 Excel 中指定的类型名称完全匹配

### 2. 数据填写

- 推荐使用枚举名称而不是数值，提高可读性
- 枚举名称不区分大小写
- 如果枚举值无法解析，将使用默认值 0

### 3. 类型安全

- 生成的代码具有完整的类型安全性
- 可以直接使用枚举进行比较和判断
- 避免了字符串比较的性能开销

### 4. 序列化

- 枚举值在二进制文件中以 int 类型存储
- 保持了数据的紧凑性和读取效率
- 支持枚举值的向后兼容性

## 错误处理

### 1. 枚举类型不存在

如果指定的枚举类型在代码中不存在，系统会：
- 输出警告日志
- 将字段类型降级为 int
- 继续正常处理数据

### 2. 枚举值无法解析

如果 Excel 中的枚举值无法解析，系统会：
- 输出错误日志
- 使用默认值 0
- 继续处理其他数据

### 3. 调试建议

- 检查 Unity Console 中的警告和错误信息
- 确认枚举类型的命名空间和访问性
- 验证 Excel 数据的格式和内容

## 最佳实践

1. **统一命名**: 使用一致的枚举命名规范
2. **文档化**: 为枚举值添加清晰的注释
3. **版本控制**: 谨慎修改已发布的枚举定义
4. **测试验证**: 在数据表构建后验证枚举值的正确性
5. **性能考虑**: 枚举比较比字符串比较更高效

通过以上指南，您可以充分利用枚举类型的优势，提高数据表的类型安全性和代码的可维护性。